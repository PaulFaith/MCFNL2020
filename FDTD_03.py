import numpy as np
from math import pi, sin
from matplotlib import pyplot as plt
#-----------------------------------------------------------------------------------------------
s_step = 200
t_step = 200
a_l =   [1.2291666667, -0.0937500000,0.0104166667]
delta_x = 10e-9
delta_t = 1.5e-17
alfa    = 0.7
e_0     = 8.854e-12
e_r     = 4
e_s     = 5.25
e_inf   = 2.25
sigma   = 0.04
k_start = 100
Xi_3    = 7e-2
tao_D   = 1
b_D     = 1
delta_eD= 1
omega_L = 4.0e14
delta_L = 2.0e9
delta_eL= 1
omega_R = 1
delta_R = 1

#-----------------------------------------------------------------------------------------------
dH  =   np.zeros((s_step,t_step))
H   =   np.zeros((s_step,t_step))
D   =   np.zeros((s_step,t_step))
E   =   np.zeros((s_step,t_step))
P_D =   np.zeros((s_step,t_step))
P_L =   np.zeros((s_step,t_step))
P_K =   np.zeros((s_step,t_step))
SR  =   np.zeros((s_step,t_step))

#----------------------------------------------------------------------------------------------
a_D =   0#(2*tao_D-delta_t)/(2*tao_D+delta_t)
b_D =   0#(e_0*delta_eD*delta_t)/(2*tao_D+delta_t)
a_L =   (2-(omega_L**2)*delta_t**2)/(1+delta_L*delta_t)
b_L =   -(1-delta_L*delta_t)/(1+delta_L*delta_t)
c_L =   (e_0*delta_eL*(omega_L**2)*(delta_t**2))/(1+delta_L*delta_t)
a_R =   (2-(omega_R**2)*(delta_t**2))/(1+delta_R*delta_t)
b_R =   -(1-delta_R*delta_t)/(1+delta_R*delta_t)
c_R =   ((1-alfa)*Xi_3*(omega_R**2)*(delta_t**2))/(1+delta_R*delta_t)
#-----------------------------------------------------------------------------------------------
#Programa principal ----------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------
s=0
E[0,0]=1
for t in range (1,t_step-1):
    #Cálculo de delta-H
    sum_al=0
    for k in range (0,len(a_l)):
        sum_al += a_l[k]*((H[s,k+1])-(H[s,k-1]))
    dH[s,t]=(1/delta_x)*sum_al
    #Cálculo de la Densidad de Campo - D
    D[s,t+1]=D[s,t]+delta_t*dH[s,t]
    #Dispersión lineal de Debye
    P_D[s,t+1]=a_D*P_D[s,t]+b_D*(E[s,t+1]-E[s,t])
    #Dispersión lineal de Lorentz
    P_L[s,t+1]=a_L*P_L[s,t]+b_L*P_L[s,t-1]+c_L*E[s,t]
    #No Linealidad de Kerr instantánea
    P_K[s,t+1]=alfa*e_0*Xi_3 *(E[s,t+1])**3
    #No Linealidad de Raman instantánea
    SR[s,t+1]=a_R*SR[s,t]+b_R*SR[s,t-1]+c_R*(E[s,t])**2
    #Actualización de la ecuación constitutiva
    E[s,t+1]=(D[s,t+1]-a_D*P_D[s,t]-b_D*E[s,t]-P_L[s,t+1])/(e_0*(e_inf+(b_D/e_0)+alfa*Xi_3*((E[s,t+1])**2)+SR[s,t+1]))
    #H
    H[s,t+1]=H[s,t]+delta_t*(E[s,t]-E[s,t-1])
    #for k in range(s_step - 1):
     #   H[k,t] = H[k,t] + 0.5 * (E[k,t] - E[k + 1,t])
#################
ss=np.linspace(0,t_step,t_step)
for i in range (1,t_step):
    ss[i]=i*delta_t
plt.plot(ss,E[0,:])
# Plot Fig. 1.6 (generated by method described in Sec. 2.1)
#plt.rcParams['font.size'] = 12
#plt.figure(figsize=(8, 2.25))
#plt.plot(ex, color='k', linewidth=1)
# plt.ylabel('E$_x$', fontsize='14')
# plt.xticks(np.arange(0, 199, step=20))
# plt.xlim(0, 199)
# plt.yticks(np.arange(-1, 1.2, step=1))
# plt.ylim(-1.2, 1.2)
# plt.text(50, 0.5, 'T = {}'.format(time_step),
# horizontalalignment='center')
# plt.plot(gbx / gbx[k_start], 'k--',
# linewidth=0.75) # Scaled for plotting
# plt.text(170, 0.5, 'Eps = {}'.format(epsr),
# horizontalalignment='center')
# plt.text(170, -0.5, 'Cond = {}'.format(sigma),
# horizontalalignment='center')
#plt.xlabel('FDTD cells')
#plt.subplots_adjust(bottom=0.25, hspace=0.45)
plt.show()